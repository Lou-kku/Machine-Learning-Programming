### 기계학습프로그래밍 위클리 노트

**2주차의 주제**



### **왜 윈도우 슬라이딩과 오버래핑을 해야 하는가?**
슬라이딩 윈도우와 오버래핑은 연속된 센서 데이터를 CNN 모델이 처리할 수 있는 고정된 형태의 입력으로 변환하는 핵심적인 데이터 전처리 기법이며, `get_frames` 함수는 이 과정을 코드로 구현한 부분입니다.

CNN은 주로 이미지와 같은 고정된 크기의 2D 데이터 처리에 최적화된 모델입니다. 하지만 WISDM 데이터셋과 같은 센서 데이터는 끊임없이 생성되는 연속적인 시계열 데이터입니다.

따라서 다음과 같은 변환 과정이 필요합니다.

1.  **연속된 데이터를 고정된 크기로 자르기**
    * CNN 모델은 입력 데이터의 차원이 일정해야 합니다. 시계열 데이터를 그대로 넣을 수는 없으므로, 일정한 길이의 '시간 윈도우(Time Window)'로 데이터를 잘라야 합니다. 이 윈도우 하나가 CNN의 입력 샘플이 됩니다.
    * 이 과정을 통해 1차원(시간)으로만 이루어진 데이터가 **(윈도우 크기, 특징 수)**의 2차원 데이터로 변환되어 CNN의 컨볼루션 연산(Convolution Operation)이 가능해집니다.

2.  **데이터의 손실을 방지하고 샘플 수를 늘리기 위해 윈도우 겹치기**
    * 만약 윈도우를 겹치지 않고 자른다면, 한 윈도우 끝에서 다른 윈도우 시작 부분에 걸쳐 발생하는 중요한 활동(예: '걷기'에서 '뛰기'로 전환되는 순간)을 놓칠 수 있습니다.
    * **오버래핑(Overlapping)**을 통해 윈도우를 일정 부분 겹쳐서 이동시키면, 이러한 경계의 중요한 패턴을 포착할 수 있습니다.
    * 또한, 오버래핑은 전체 학습 데이터의 수를 크게 늘려 모델의 일반화 성능을 향상시키는 효과도 있습니다.

결론적으로, 슬라이딩 윈도우와 오버래핑은 연속적인 시계열 데이터를 CNN이 처리할 수 있는 고정된 2D 샘플들로 변환하고, 이 과정에서 데이터의 중요한 정보를 보존하며 학습 데이터의 양을 늘리기 위한 필수적인 전처리 기법입니다.

---

### **`get_frames` 함수의 중요성**

`get_frames` 함수는 위에서 설명한 슬라이딩 윈도우와 오버래핑 기법을 직접 구현한 코드입니다. 이 함수를 이해하는 것이 중요한 이유는 이 코드가 raw 데이터를 CNN에 입력할 수 있는 최종 형태로 가공하는 핵심 로직이기 때문입니다.

코드의 주요 부분을 단계별로 살펴보겠습니다.

* **`for i in range(0, len(df) - frame_size, hop_size):`**
    * 이 부분이 바로 슬라이딩 윈도우와 오버래핑을 구현하는 핵심 루프입니다.
    * `range` 함수는 0부터 시작하여 `len(df) - frame_size`까지 `hop_size` 간격으로 `i` 값을 증가시킵니다.
    * `frame_size`는 윈도우의 크기를, `hop_size`는 윈도우가 한 번에 이동하는 거리를 결정합니다. 만약 `hop_size < frame_size`라면, 윈도우가 겹치게 됩니다.

* **`x = df['x'].values[i:i+frame_size]` 외 3줄**
    * 루프가 한 번 돌 때마다, 현재 윈도우의 시작점 `i`부터 `i + frame_size`까지의 데이터를 슬라이싱(slicing)하여 각 센서 축(x, y, z)의 값을 추출합니다.
    * 이 추출된 데이터가 바로 모델의 하나의 입력 샘플(Input Sample)이 됩니다.

* **`label = stats.mode(df['label'][i:i+frame_size], keepdims=True).mode[0]:`**
    * 이 부분은 추출된 윈도우 전체에 대해 하나의 라벨을 지정하는 로직입니다.
    * `stats.mode` 함수는 주어진 데이터에서 가장 빈번하게 나타나는 값(최빈값)을 찾습니다.
    * 이 코드는 윈도우 내에서 가장 많이 발생한 활동(예: '걷기')을 해당 윈도우의 대표 라벨로 설정합니다. 이렇게 해야 CNN 모델이 윈도우 전체에 대해 특정 활동을 예측할 수 있습니다.

* **`frames = np.asarray(frames).reshape(-1, frame_size, N_FEATURES):`**
    * 마지막으로, `frames` 리스트에 쌓인 모든 윈도우를 NumPy 배열로 변환합니다.
    * `reshape` 함수를 사용하여 최종적으로 CNN 모델에 입력 가능한 **(샘플 수, 윈도우 크기, 특징 수)** 형태의 3D 텐서(Tensor)로 재구성합니다.

따라서 `get_frames` 함수는 이 프로젝트의 데이터 전처리 파이프라인에서 가장 중요한 역할을 수행하며, CNN 모델이 시계열 데이터를 성공적으로 학습할 수 있도록 데이터를 준비하는 핵심적인 연결 고리입니다.
